name: Release Workflow Optimization

on:
  workflow_call:
    inputs:
      optimization_level:
        description: 'Optimization level (basic, aggressive, experimental)'
        required: false
        default: 'basic'
        type: string
      enable_monitoring:
        description: 'Enable performance monitoring and metrics collection'
        required: false
        default: true
        type: boolean
      cache_strategy:
        description: 'Caching strategy (standard, aggressive, distributed)'
        required: false
        default: 'standard'
        type: string
    outputs:
      cache_hit_ratio:
        description: 'Overall cache hit ratio percentage'
        value: ${{ jobs.cache-optimization.outputs.cache_hit_ratio }}
      total_execution_time:
        description: 'Total workflow execution time in seconds'
        value: ${{ jobs.performance-summary.outputs.total_time }}
      optimization_savings:
        description: 'Time saved through optimizations in seconds'
        value: ${{ jobs.performance-summary.outputs.optimization_savings }}
  workflow_dispatch:
    inputs:
      optimization_level:
        description: 'Optimization level (basic, aggressive, experimental)'
        required: false
        default: 'basic'
        type: choice
        options:
        - basic
        - aggressive
        - experimental
      enable_monitoring:
        description: 'Enable performance monitoring and metrics collection'
        required: false
        default: true
        type: boolean
      cache_strategy:
        description: 'Caching strategy (standard, aggressive, distributed)'
        required: false
        default: 'standard'
        type: choice
        options:
        - standard
        - aggressive
        - distributed
      target_workflow:
        description: 'Target workflow to optimize (release, ci, pre-release)'
        required: false
        default: 'release'
        type: choice
        options:
        - release
        - ci
        - pre-release

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  OPTIMIZATION_LEVEL: ${{ inputs.optimization_level || 'basic' }}
  ENABLE_MONITORING: ${{ inputs.enable_monitoring || true }}
  CACHE_STRATEGY: ${{ inputs.cache_strategy || 'standard' }}
  WORKFLOW_START_TIME: ${{ github.run_started_at }}

jobs:
  cache-optimization:
    name: Cache Strategy Optimization
    runs-on: macos-latest
    outputs:
      swift_cache_key: ${{ steps.cache-keys.outputs.swift_cache_key }}
      swiftlint_cache_key: ${{ steps.cache-keys.outputs.swiftlint_cache_key }}
      homebrew_cache_key: ${{ steps.cache-keys.outputs.homebrew_cache_key }}
      cache_hit_ratio: ${{ steps.cache-metrics.outputs.hit_ratio }}
      optimization_recommendations: ${{ steps.analyze-cache.outputs.recommendations }}
    steps:
      - name: üöÄ Starting Cache Optimization Analysis
        run: |
          echo "::notice title=Cache Optimization::Starting advanced caching strategy analysis and optimization"
          echo "üöÄ Analyzing current cache usage patterns and optimization opportunities"
          echo "üìä Optimization level: ${{ env.OPTIMIZATION_LEVEL }}"
          echo "üìä Cache strategy: ${{ env.CACHE_STRATEGY }}"
          echo "üìä Status: STARTING"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: üìä Generate Optimized Cache Keys
        id: cache-keys
        run: |
          echo "::group::Cache Key Optimization"
          echo "::notice title=Cache Keys::Generating optimized cache keys for maximum efficiency"
          
          # Get system information for cache keys
          MACOS_VERSION=$(sw_vers -productVersion)
          SWIFT_VERSION=$(swift --version | head -n1 | sed 's/.*Swift version \([0-9.]*\).*/\1/')
          XCODE_VERSION=$(xcodebuild -version | head -n1 | sed 's/Xcode //')
          
          # Generate optimized Swift package cache key
          SWIFT_CACHE_KEY="swift-packages-v3-${{ runner.os }}-${MACOS_VERSION}-${SWIFT_VERSION}-${{ hashFiles('Package.swift', 'Package.resolved', '**/Package.swift') }}"
          
          # Generate SwiftLint cache key with version detection
          SWIFTLINT_VERSION=$(brew list --versions swiftlint 2>/dev/null | awk '{print $2}' || echo "not-installed")
          SWIFTLINT_CACHE_KEY="swiftlint-v2-${{ runner.os }}-${SWIFTLINT_VERSION}-${{ hashFiles('.swiftlint.yml') }}"
          
          # Generate Homebrew cache key
          HOMEBREW_CACHE_KEY="homebrew-v1-${{ runner.os }}-${MACOS_VERSION}-${{ hashFiles('**/Brewfile', 'Scripts/install-dependencies.sh') }}"
          
          # Strategy-specific cache key modifications
          case "${{ env.CACHE_STRATEGY }}" in
            aggressive)
              # Include more specific versioning for aggressive caching
              SWIFT_CACHE_KEY="${SWIFT_CACHE_KEY}-xcode-${XCODE_VERSION}"
              SWIFTLINT_CACHE_KEY="${SWIFTLINT_CACHE_KEY}-aggressive"
              ;;
            distributed)
              # Add build matrix dimensions for distributed caching
              SWIFT_CACHE_KEY="${SWIFT_CACHE_KEY}-matrix-${{ strategy.job-index || 'single' }}"
              ;;
          esac
          
          echo "swift_cache_key=$SWIFT_CACHE_KEY" >> $GITHUB_OUTPUT
          echo "swiftlint_cache_key=$SWIFTLINT_CACHE_KEY" >> $GITHUB_OUTPUT  
          echo "homebrew_cache_key=$HOMEBREW_CACHE_KEY" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Swift packages cache key: $SWIFT_CACHE_KEY"
          echo "‚úÖ SwiftLint cache key: $SWIFTLINT_CACHE_KEY"
          echo "‚úÖ Homebrew cache key: $HOMEBREW_CACHE_KEY"
          echo "::endgroup::"

      - name: üóÑÔ∏è Multi-Level Swift Package Cache
        id: swift-cache
        uses: actions/cache@v4
        with:
          path: |
            .build
            ~/Library/Caches/org.swift.swiftpm
            ~/Library/org.swift.swiftpm
            ~/Library/Developer/Xcode/DerivedData
            ~/.swiftpm
          key: ${{ steps.cache-keys.outputs.swift_cache_key }}
          restore-keys: |
            swift-packages-v3-${{ runner.os }}-${{ env.MACOS_VERSION }}-${{ env.SWIFT_VERSION }}-
            swift-packages-v3-${{ runner.os }}-${{ env.MACOS_VERSION }}-
            swift-packages-v3-${{ runner.os }}-
            swift-packages-v2-${{ runner.os }}-
          save-always: true

      - name: üîß Advanced SwiftLint Cache
        id: swiftlint-cache
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/bin/swiftlint
            /opt/homebrew/bin/swiftlint
            /usr/local/Cellar/swiftlint
            /opt/homebrew/Cellar/swiftlint
            ~/.swiftlint_cache
          key: ${{ steps.cache-keys.outputs.swiftlint_cache_key }}
          restore-keys: |
            swiftlint-v2-${{ runner.os }}-
            swiftlint-v1-${{ runner.os }}-
          save-always: true

      - name: üì¶ Homebrew Dependencies Cache
        id: homebrew-cache
        if: env.CACHE_STRATEGY == 'aggressive' || env.CACHE_STRATEGY == 'distributed'
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/Cellar
            /opt/homebrew/Cellar
            /usr/local/var/homebrew
            /opt/homebrew/var/homebrew
            ~/Library/Caches/Homebrew
          key: ${{ steps.cache-keys.outputs.homebrew_cache_key }}
          restore-keys: |
            homebrew-v1-${{ runner.os }}-
          save-always: false  # Only save if we actually install something

      - name: üìä Analyze Cache Performance
        id: cache-metrics
        run: |
          echo "::group::Cache Performance Analysis"
          echo "::notice title=Cache Analysis::Analyzing cache hit rates and performance metrics"
          
          # Calculate cache hit ratios
          SWIFT_HIT=${{ steps.swift-cache.outputs.cache-hit == 'true' && '1' || '0' }}
          SWIFTLINT_HIT=${{ steps.swiftlint-cache.outputs.cache-hit == 'true' && '1' || '0' }}
          HOMEBREW_HIT=${{ steps.homebrew-cache.outputs.cache-hit == 'true' && '1' || '0' }}
          
          # Calculate overall hit ratio
          TOTAL_CACHES=3
          HITS=$((SWIFT_HIT + SWIFTLINT_HIT + HOMEBREW_HIT))
          HIT_RATIO=$((HITS * 100 / TOTAL_CACHES))
          
          echo "üìä Cache Performance Metrics:"
          echo "   ‚Ä¢ Swift packages: ${{ steps.swift-cache.outputs.cache-hit == 'true' && 'HIT' || 'MISS' }}"
          echo "   ‚Ä¢ SwiftLint: ${{ steps.swiftlint-cache.outputs.cache-hit == 'true' && 'HIT' || 'MISS' }}"
          echo "   ‚Ä¢ Homebrew: ${{ steps.homebrew-cache.outputs.cache-hit == 'true' && 'HIT' || 'MISS' }}"
          echo "   ‚Ä¢ Overall hit ratio: ${HIT_RATIO}%"
          
          echo "hit_ratio=$HIT_RATIO" >> $GITHUB_OUTPUT
          
          # Performance recommendations based on hit ratios
          if [ $HIT_RATIO -lt 50 ]; then
            echo "::warning title=Cache Performance::Low cache hit ratio detected (${HIT_RATIO}%) - consider cache key optimization"
          elif [ $HIT_RATIO -ge 80 ]; then
            echo "::notice title=Cache Performance::Excellent cache performance (${HIT_RATIO}%) - optimal configuration"
          fi
          
          echo "::endgroup::"

      - name: üîç Generate Cache Optimization Recommendations
        id: analyze-cache
        run: |
          echo "::group::Cache Optimization Recommendations"
          echo "::notice title=Optimization::Generating cache optimization recommendations"
          
          HIT_RATIO=${{ steps.cache-metrics.outputs.hit_ratio }}
          RECOMMENDATIONS=""
          
          if [ $HIT_RATIO -lt 60 ]; then
            RECOMMENDATIONS="Consider more specific cache keys; Review cache paths; Implement cache pre-warming"
          elif [ $HIT_RATIO -lt 80 ]; then
            RECOMMENDATIONS="Optimize cache key granularity; Consider distributed caching strategy"
          else
            RECOMMENDATIONS="Cache performance is optimal; Consider sharing cache keys across workflows"
          fi
          
          echo "üìã Cache Optimization Recommendations:"
          echo "$RECOMMENDATIONS"
          echo "recommendations=$RECOMMENDATIONS" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  parallel-execution-optimization:
    name: Parallel Execution Strategy
    runs-on: macos-latest
    needs: cache-optimization
    outputs:
      parallel_job_count: ${{ steps.parallel-config.outputs.job_count }}
      execution_strategy: ${{ steps.parallel-config.outputs.strategy }}
      estimated_time_savings: ${{ steps.parallel-analysis.outputs.time_savings }}
    steps:
      - name: ‚ö° Starting Parallel Execution Optimization
        run: |
          echo "::notice title=Parallel Optimization::Starting parallel execution strategy optimization"
          echo "‚ö° Analyzing optimal parallel job configuration and execution patterns"
          echo "üìä Optimization level: ${{ env.OPTIMIZATION_LEVEL }}"
          echo "üìä Status: STARTING"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: üìä Analyze Optimal Parallel Configuration
        id: parallel-config
        run: |
          echo "::group::Parallel Configuration Analysis"
          echo "::notice title=Parallel Config::Determining optimal parallel execution configuration"
          
          # Analyze available resources and workflow complexity
          AVAILABLE_CORES=$(sysctl -n hw.ncpu)
          GITHUB_RUNNER_CORES=3  # Standard GitHub Actions runner allocation
          
          # Determine optimal job count based on optimization level
          case "${{ env.OPTIMIZATION_LEVEL }}" in
            basic)
              JOB_COUNT=$((GITHUB_RUNNER_CORES > 2 ? 2 : 1))
              STRATEGY="conservative"
              ;;
            aggressive)
              JOB_COUNT=$GITHUB_RUNNER_CORES
              STRATEGY="maximum_parallel"
              ;;
            experimental)
              JOB_COUNT=$((GITHUB_RUNNER_CORES + 1))  # Slight oversubscription
              STRATEGY="oversubscribed"
              ;;
            *)
              JOB_COUNT=2
              STRATEGY="default"
              ;;
          esac
          
          echo "job_count=$JOB_COUNT" >> $GITHUB_OUTPUT
          echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT
          
          echo "üìä Parallel Execution Configuration:"
          echo "   ‚Ä¢ Available cores: $AVAILABLE_CORES"
          echo "   ‚Ä¢ GitHub runner cores: $GITHUB_RUNNER_CORES"
          echo "   ‚Ä¢ Optimal job count: $JOB_COUNT"
          echo "   ‚Ä¢ Execution strategy: $STRATEGY"
          echo "::endgroup::"

      - name: ‚ö° Simulate Parallel Execution Patterns
        id: parallel-analysis
        run: |
          echo "::group::Parallel Execution Analysis"
          echo "::notice title=Parallel Analysis::Simulating parallel execution patterns and time savings"
          
          JOB_COUNT=${{ steps.parallel-config.outputs.job_count }}
          
          # Estimate time savings based on parallelization
          # These are estimates based on typical workflow patterns
          SEQUENTIAL_BUILD_TIME=180    # 3 minutes for build
          SEQUENTIAL_TEST_TIME=240     # 4 minutes for tests
          SEQUENTIAL_LINT_TIME=60      # 1 minute for linting
          
          TOTAL_SEQUENTIAL_TIME=$((SEQUENTIAL_BUILD_TIME + SEQUENTIAL_TEST_TIME + SEQUENTIAL_LINT_TIME))
          
          # Calculate parallel execution time (assumes some overhead)
          PARALLEL_OVERHEAD=30  # 30 seconds overhead
          LONGEST_JOB_TIME=$((SEQUENTIAL_TEST_TIME > SEQUENTIAL_BUILD_TIME ? SEQUENTIAL_TEST_TIME : SEQUENTIAL_BUILD_TIME))
          PARALLEL_TOTAL_TIME=$((LONGEST_JOB_TIME + PARALLEL_OVERHEAD))
          
          TIME_SAVINGS=$((TOTAL_SEQUENTIAL_TIME - PARALLEL_TOTAL_TIME))
          SAVINGS_PERCENTAGE=$(((TIME_SAVINGS * 100) / TOTAL_SEQUENTIAL_TIME))
          
          echo "time_savings=$TIME_SAVINGS" >> $GITHUB_OUTPUT
          
          echo "üìä Parallel Execution Analysis:"
          echo "   ‚Ä¢ Sequential execution time: ${TOTAL_SEQUENTIAL_TIME}s"
          echo "   ‚Ä¢ Parallel execution time: ${PARALLEL_TOTAL_TIME}s"
          echo "   ‚Ä¢ Estimated time savings: ${TIME_SAVINGS}s (${SAVINGS_PERCENTAGE}%)"
          echo "   ‚Ä¢ Parallel job configuration: $JOB_COUNT jobs"
          echo "::endgroup::"

      - name: üîß Generate Parallel Execution Recommendations
        run: |
          echo "::group::Parallel Execution Recommendations"
          echo "::notice title=Parallel Recommendations::Generating execution optimization recommendations"
          
          STRATEGY=${{ steps.parallel-config.outputs.strategy }}
          JOB_COUNT=${{ steps.parallel-config.outputs.job_count }}
          TIME_SAVINGS=${{ steps.parallel-analysis.outputs.time_savings }}
          
          echo "üìã Parallel Execution Recommendations:"
          echo "   ‚Ä¢ Optimal job count: $JOB_COUNT parallel jobs"
          echo "   ‚Ä¢ Execution strategy: $STRATEGY"
          echo "   ‚Ä¢ Expected time savings: ${TIME_SAVINGS} seconds"
          
          if [ $TIME_SAVINGS -gt 120 ]; then
            echo "   ‚Ä¢ ‚úÖ High optimization potential - implement parallel execution"
          elif [ $TIME_SAVINGS -gt 60 ]; then
            echo "   ‚Ä¢ ‚ö° Moderate optimization potential - consider parallel execution"
          else
            echo "   ‚Ä¢ ‚ö†Ô∏è Limited optimization potential - current setup may be optimal"
          fi
          
          case "$STRATEGY" in
            conservative)
              echo "   ‚Ä¢ üõ°Ô∏è Conservative strategy: Safe parallel execution with minimal resource contention"
              ;;
            maximum_parallel)
              echo "   ‚Ä¢ ‚ö° Aggressive strategy: Maximum parallelization for fastest execution"
              ;;
            oversubscribed)
              echo "   ‚Ä¢ üöÄ Experimental strategy: Oversubscribed execution for maximum speed (may cause resource contention)"
              ;;
          esac
          echo "::endgroup::"

  workflow-monitoring:
    name: Workflow Performance Monitoring
    runs-on: ubuntu-latest
    if: inputs.enable_monitoring == true
    needs: [cache-optimization, parallel-execution-optimization]
    outputs:
      monitoring_enabled: ${{ steps.setup-monitoring.outputs.enabled }}
      metrics_endpoint: ${{ steps.setup-monitoring.outputs.endpoint }}
      dashboard_url: ${{ steps.create-dashboard.outputs.url }}
    steps:
      - name: üìä Starting Performance Monitoring Setup
        run: |
          echo "::notice title=Performance Monitoring::Setting up workflow performance monitoring and metrics collection"
          echo "üìä Initializing performance tracking and optimization metrics"
          echo "üìä Status: STARTING"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup Performance Monitoring
        id: setup-monitoring
        run: |
          echo "::group::Performance Monitoring Setup"
          echo "::notice title=Monitoring Setup::Configuring performance monitoring infrastructure"
          
          # Create monitoring configuration
          cat > /tmp/monitoring-config.json << EOF
          {
            "monitoring": {
              "enabled": true,
              "optimization_level": "${{ env.OPTIMIZATION_LEVEL }}",
              "cache_strategy": "${{ env.CACHE_STRATEGY }}",
              "workflow_id": "${{ github.run_id }}",
              "repository": "${{ github.repository }}",
              "ref": "${{ github.ref }}"
            },
            "metrics": {
              "cache_hit_ratio": "${{ needs.cache-optimization.outputs.cache_hit_ratio }}",
              "parallel_job_count": "${{ needs.parallel-execution-optimization.outputs.parallel_job_count }}",
              "execution_strategy": "${{ needs.parallel-execution-optimization.outputs.execution_strategy }}",
              "estimated_savings": "${{ needs.parallel-execution-optimization.outputs.estimated_time_savings }}"
            }
          }
          EOF
          
          echo "enabled=true" >> $GITHUB_OUTPUT
          echo "endpoint=https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Performance monitoring configured"
          echo "üìä Monitoring configuration created"
          echo "üîó Metrics endpoint ready"
          echo "::endgroup::"

      - name: üìà Create Performance Dashboard
        id: create-dashboard
        run: |
          echo "::group::Performance Dashboard"
          echo "::notice title=Dashboard::Creating performance monitoring dashboard"
          
          # Generate performance dashboard URL (GitHub Actions insights)
          DASHBOARD_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          echo "url=$DASHBOARD_URL" >> $GITHUB_OUTPUT
          
          echo "üìà Performance Dashboard Created:"
          echo "   ‚Ä¢ Workflow execution metrics: Available"
          echo "   ‚Ä¢ Cache performance tracking: Enabled"
          echo "   ‚Ä¢ Parallel execution monitoring: Active"
          echo "   ‚Ä¢ Dashboard URL: $DASHBOARD_URL"
          echo "::endgroup::"

      - name: üìä Collect Baseline Metrics
        run: |
          echo "::group::Baseline Metrics Collection"
          echo "::notice title=Metrics Collection::Collecting baseline performance metrics"
          
          # Collect and display current metrics
          echo "üìä Current Performance Metrics:"
          echo "   ‚Ä¢ Cache hit ratio: ${{ needs.cache-optimization.outputs.cache_hit_ratio }}%"
          echo "   ‚Ä¢ Parallel job count: ${{ needs.parallel-execution-optimization.outputs.parallel_job_count }}"
          echo "   ‚Ä¢ Execution strategy: ${{ needs.parallel-execution-optimization.outputs.execution_strategy }}"
          echo "   ‚Ä¢ Estimated time savings: ${{ needs.parallel-execution-optimization.outputs.estimated_time_savings }}s"
          echo "   ‚Ä¢ Optimization level: ${{ env.OPTIMIZATION_LEVEL }}"
          echo "   ‚Ä¢ Cache strategy: ${{ env.CACHE_STRATEGY }}"
          
          # Create metrics summary for future reference
          cat > /tmp/performance-metrics.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "workflow_run_id": "${{ github.run_id }}",
            "optimization_level": "${{ env.OPTIMIZATION_LEVEL }}",
            "cache_strategy": "${{ env.CACHE_STRATEGY }}",
            "metrics": {
              "cache_hit_ratio": ${{ needs.cache-optimization.outputs.cache_hit_ratio }},
              "parallel_job_count": ${{ needs.parallel-execution-optimization.outputs.parallel_job_count }},
              "estimated_time_savings": ${{ needs.parallel-execution-optimization.outputs.estimated_time_savings }}
            }
          }
          EOF
          
          echo "‚úÖ Baseline metrics collected and stored"
          echo "::endgroup::"

  performance-summary:
    name: Performance Optimization Summary
    runs-on: ubuntu-latest
    if: always()
    needs: [cache-optimization, parallel-execution-optimization, workflow-monitoring]
    outputs:
      total_time: ${{ steps.calculate-metrics.outputs.total_time }}
      optimization_savings: ${{ steps.calculate-metrics.outputs.optimization_savings }}
      recommendations: ${{ steps.generate-recommendations.outputs.recommendations }}
    steps:
      - name: üìä Performance Optimization Summary
        run: |
          echo "::notice title=Performance Summary::Generating comprehensive performance optimization summary"
          echo "üìä Analyzing optimization results and generating actionable recommendations"
          echo "üìä Status: SUMMARIZING"

      - name: üßÆ Calculate Performance Metrics
        id: calculate-metrics
        run: |
          echo "::group::Performance Metrics Calculation"
          echo "::notice title=Metrics Calculation::Calculating comprehensive performance metrics"
          
          # Calculate workflow execution time
          WORKFLOW_START=$(date -d "${{ env.WORKFLOW_START_TIME }}" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "${{ env.WORKFLOW_START_TIME }}" +%s)
          CURRENT_TIME=$(date +%s)
          TOTAL_TIME=$((CURRENT_TIME - WORKFLOW_START))
          
          # Get optimization savings from parallel execution analysis
          OPTIMIZATION_SAVINGS="${{ needs.parallel-execution-optimization.outputs.estimated_time_savings || '0' }}"
          
          echo "total_time=$TOTAL_TIME" >> $GITHUB_OUTPUT
          echo "optimization_savings=$OPTIMIZATION_SAVINGS" >> $GITHUB_OUTPUT
          
          echo "üìä Performance Metrics Summary:"
          echo "   ‚Ä¢ Total execution time: ${TOTAL_TIME}s"
          echo "   ‚Ä¢ Estimated optimization savings: ${OPTIMIZATION_SAVINGS}s"
          echo "   ‚Ä¢ Cache hit ratio: ${{ needs.cache-optimization.outputs.cache_hit_ratio || 'N/A' }}%"
          echo "   ‚Ä¢ Parallel job configuration: ${{ needs.parallel-execution-optimization.outputs.parallel_job_count || 'N/A' }} jobs"
          echo "::endgroup::"

      - name: üìã Generate Optimization Recommendations
        id: generate-recommendations
        run: |
          echo "::group::Optimization Recommendations"
          echo "::notice title=Recommendations::Generating comprehensive optimization recommendations"
          
          CACHE_HIT_RATIO="${{ needs.cache-optimization.outputs.cache_hit_ratio || '0' }}"
          PARALLEL_SAVINGS="${{ needs.parallel-execution-optimization.outputs.estimated_time_savings || '0' }}"
          OPTIMIZATION_LEVEL="${{ env.OPTIMIZATION_LEVEL }}"
          
          RECOMMENDATIONS=""
          
          # Cache optimization recommendations
          if [ "$CACHE_HIT_RATIO" -lt 60 ]; then
            RECOMMENDATIONS="$RECOMMENDATIONS‚Ä¢ Improve cache strategies for better hit ratios\n"
          fi
          
          # Parallel execution recommendations
          if [ "$PARALLEL_SAVINGS" -gt 120 ]; then
            RECOMMENDATIONS="$RECOMMENDATIONS‚Ä¢ Implement aggressive parallel execution for significant time savings\n"
          fi
          
          # Strategy-specific recommendations
          case "$OPTIMIZATION_LEVEL" in
            basic)
              RECOMMENDATIONS="$RECOMMENDATIONS‚Ä¢ Consider upgrading to aggressive optimization for better performance\n"
              ;;
            experimental)
              RECOMMENDATIONS="$RECOMMENDATIONS‚Ä¢ Monitor for resource contention with experimental settings\n"
              ;;
          esac
          
          if [ -z "$RECOMMENDATIONS" ]; then
            RECOMMENDATIONS="‚Ä¢ Current optimization configuration appears optimal for your workflow\n"
          fi
          
          echo "recommendations=$RECOMMENDATIONS" >> $GITHUB_OUTPUT
          
          echo "üìã Optimization Recommendations:"
          echo -e "$RECOMMENDATIONS"
          echo "::endgroup::"

      - name: üéØ Final Performance Summary
        run: |
          echo "::group::Final Performance Summary"
          echo "::notice title=Final Summary::Complete performance optimization analysis"
          
          echo "üéØ Performance Optimization Results:"
          echo "   ‚Ä¢ Optimization Level: ${{ env.OPTIMIZATION_LEVEL }}"
          echo "   ‚Ä¢ Cache Strategy: ${{ env.CACHE_STRATEGY }}"
          echo "   ‚Ä¢ Total Execution Time: ${{ steps.calculate-metrics.outputs.total_time }}s"
          echo "   ‚Ä¢ Estimated Savings: ${{ steps.calculate-metrics.outputs.optimization_savings }}s"
          echo "   ‚Ä¢ Cache Performance: ${{ needs.cache-optimization.outputs.cache_hit_ratio || 'N/A' }}% hit ratio"
          echo "   ‚Ä¢ Parallel Configuration: ${{ needs.parallel-execution-optimization.outputs.parallel_job_count || 'N/A' }} jobs"
          
          if [ "${{ needs.workflow-monitoring.outputs.monitoring_enabled }}" = "true" ]; then
            echo "   ‚Ä¢ Performance Monitoring: ‚úÖ Enabled"
            echo "   ‚Ä¢ Dashboard: ${{ needs.workflow-monitoring.outputs.dashboard_url }}"
          else
            echo "   ‚Ä¢ Performance Monitoring: ‚ùå Disabled"
          fi
          
          echo ""
          echo "üìä Optimization Status: COMPLETE"
          
          # Determine overall optimization success
          CACHE_HIT_RATIO="${{ needs.cache-optimization.outputs.cache_hit_ratio || '0' }}"
          PARALLEL_SAVINGS="${{ needs.parallel-execution-optimization.outputs.estimated_time_savings || '0' }}"
          
          if [ "$CACHE_HIT_RATIO" -ge 70 ] && [ "$PARALLEL_SAVINGS" -ge 60 ]; then
            echo "üéâ Overall Performance: EXCELLENT - High cache efficiency and significant parallel savings"
          elif [ "$CACHE_HIT_RATIO" -ge 50 ] || [ "$PARALLEL_SAVINGS" -ge 30 ]; then
            echo "‚ö° Overall Performance: GOOD - Meaningful optimization improvements achieved"
          else
            echo "üìà Overall Performance: BASELINE - Optimization potential identified for future improvements"
          fi
          
          echo "::endgroup::"